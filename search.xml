<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 时间数据类型处理</title>
      <link href="/2019/12/24/Python-%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/24/Python-%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>编写Python程序处理数据时，常遇到时间格式的字符串数据，有时涉及到时间的加减运算。在Python中，有专门的时间结构的数据对象来表示时间数据，实际中，我们常喜欢用字符串数据来表示时间，或者整型的时间戳。因此常涉及这三种时间数据类型的转换操作。</p><a id="more"></a><img src="/2019/12/24/Python-时间数据类型处理/time_struct.png"><h4>1. 获取当前时间戳</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seconds = time.time()</span><br></pre></td></tr></table></figure><h4>2. 时间戳格式转时间格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = time.localtime(seconds)</span><br></pre></td></tr></table></figure><h4>3. 时间格式转字符串格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time)</span><br></pre></td></tr></table></figure><h4>4. 时间戳转换为字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime(seconds))</span><br></pre></td></tr></table></figure><h5>5. 字符串转换为时间戳</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.mktime(time.strptime(<span class="string">"2018-08-07"</span>, <span class="string">"%Y-%m-%d"</span>))</span><br></pre></td></tr></table></figure><blockquote><p>[1] lwb444:<a href="https://www.cnblogs.com/linwenbin/p/10905341.html" target="_blank" rel="external">《Python 时间戳/字符串/时间 转换》</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>核主成分分析 Kernel PCA</title>
      <link href="/2019/10/24/%E6%A0%B8%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-Kernel-PCA/"/>
      <url>/2019/10/24/%E6%A0%B8%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-Kernel-PCA/</url>
      
        <content type="html"><![CDATA[<p>在核主成分分析中，我们认为原始数据集有更高的维数，我们可以在更高维的空间中做PCA分析（即在更高维空间里，把原始数据向不同的方向投影）。原因在于：在低维空间难以线性分类的数据点，我们有可能再更高维度上找到合适的高维线性分类平面。</p><a id="more"></a><h4>一. 核函数</h4><h5>1. 核函数的定义</h5><p>假设输入空间为X，特征空间为F（特征空间具有很高的维数，甚至无穷维），存在一个映射$\phi$将空间X中的点x映射到空间F中的点f：$$ \phi(x): X \rightarrow F $$实际应用中，我们难以确定映射$\phi$的具体形式，然而我们的主要计算需求是计算两个向量的内积，通过引入核函数，我们不需要知道映射的具体形式，便可通过低维空间的向量来计算高维空间向量的内积。<br>设：$x$，$z$是低维空间任意两个向量，那么核函数满足下述关系：$$ K(x,z) = \phi(x) \cdot \phi(z) $$</p><p>比如我们定义如下二维到三维的映射函数（这里，$x_i$表示样本$x$的第$i$个分量）：$$ \phi(x) = (x_1^2, \sqrt{2} x_1 x_2, x_2^2) $$可以验证：$$ K(x,z) = \phi(x) \cdot \phi(z) = (x \cdot z)^2 $$</p><h5>2. 核矩阵</h5><p>任意两个样本点映射到高维空间后的内积组成的矩阵称为核函数矩阵（这里，$x_i$表示第$i$个样本）：$$\begin{bmatrix}\phi(x_1) \cdot \phi(x_1) &amp; ... &amp; \phi(x_1) \cdot \phi(x_N) \\...                       &amp; ... &amp; ... \\\phi(x_N) \cdot \phi(x_1) &amp; ... &amp; \phi(x_N) \cdot \phi(x_N)\end{bmatrix}$$</p><p>常用的核函数的形式有如下几种：</p><h6>(1) 线性核</h6><p>$$ K(x,z) = x \cdot z $$</p><h6>(2) 多项式核</h6><p>$$ K(x,z) = (x \cdot z + 1)^r, r \in Z $$</p><h6>(3) 高斯核</h6><p>$$ K(x,z) = exp(-\frac{|x-z|^2}{2\sigma^2}), \sigma \in R, and\ \sigma \neq 0$$</p><p>采用核函数避免直接将原始向量映射到高维空间进行内积计算，一方面避开了映射函数的寻找，另一方面也减少了运算量。不过如果映射后的空间维数过高，导致模型在训练集上过拟合，在测试集上的泛化能力往往不加。</p><h4>二. 核技巧</h4><p>与线性主成分分析不同，核主成分分析通过在高维有映射后的特征空间进行主成分分析，设我们的原始数据矩阵为$X$：$$ [x_1, x_2, ..., x_N] $$$x_i$表示数据集中的第$i$个样本，是一个维度为$d$的列向量，这里矩阵的每一列为一个样本，样本数为$N$。我们通过映射函数$\phi(x)$将所有样本映射到维度为$D$的特征空间$F$，映射后的数据矩阵为$\phi(X)$：$$ [\phi(x_1), \phi(x_2), ..., \phi(x_N)] $$接下来对数据集$\phi(X)$进行PCA处理，这里预先假设$\phi(X)$已经经过中心化处理：$$ \sum_{i}^{N} \phi(x_i) = 0 $$在特征空间里，数据集$\phi(X)$的协方差矩阵为：$$ C_F = \frac{1}{N} \phi(X) \phi(X)^T = \frac{1}{N} \sum_{i=1}^N \phi(x_i) \phi(x_i)^T $$PCA计算实质是求解协方差矩阵$C_F$的本征值问题：$$ C_F p = \lambda p $$即：$$ \sum_{i=1}^N \phi(x_i) \phi(x_i)^T p = \lambda p $$这里不考虑因子$\frac{1}{N}$<br>降维时我们考虑的是本征值$\lambda \neq 0$的成分，我们对上式两边同消去$\lambda$，得到：$$ p = \sum_{i=1}^N \phi(x_i) [ \phi(x_i)^T p ] $$注意到上式方括号中的值是一个常数，我们用$\alpha_i$代替，于是：$$ p = \sum_{i=1}^N \alpha_i \phi(x_i) = \phi(X) \alpha $$$\alpha$是一个$N$维的向量：$[\alpha_1, \alpha_2, ..., \alpha_N]^T $<br>这里得到一个结论：特征值不为0的特征向量可表示为高维空间样本向量的线性组合。<br>将上式带入$C_F$的本征方程中得：$$ \phi(X)^T \phi(X) \phi(X)^T \phi(X) \alpha = \lambda \phi(X)^T \phi(X) \alpha $$定义核函数矩阵为：$K=\phi(X)^T \phi(X)$，上式化简为：$$ K \cdot K \alpha = \lambda K \alpha $$参考文献[1]证明为求解上式，则只需求解下述本征方程，该本征方程的特征值即原问题的本征值。$$ K \alpha = \lambda \alpha $$</p><blockquote><p>[1] B. Scholkopf, A. J. Smola, K. Muller. Nonlinear component analysis as a kernel eigenvalue problem. Neural Computation 10 (5), 1299–1399, 1998.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析PCA</title>
      <link href="/2019/10/24/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90PCA/"/>
      <url>/2019/10/24/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90PCA/</url>
      
        <content type="html"><![CDATA[<p>主成分分析是数据降维的重要手段，当样本中包含多个特征且特征之间强耦合时，将强耦合的特征综合成一个或几个特征，这样既减少了样本的维度，节约计算资源也减少过拟合的风险。在主成分分析中，每一个主成分都是数据集在某一个方向上的投影，不同方向上数据集的方差(variance)由该方向上的特征值(eigenvalue)决定，一般我们选择最大的几个特征值所在的特征向量(eigenvector)，认为在这些方向上，数据集包含了我们所需要的信息。</p><a id="more"></a><h4>1. 数据集标准化</h4><p>假设我们有一个数据集，每个样本有d个特征，共N个样本，我们构建一个$d \times N$维的矩阵$X = [x_1, x_2, ..., x_N]$，矩阵的每一列对应一个样本，矩阵的每一行对应一个特征。</p><p>由于数据集中的每个特征来源于不同的变量，往往具有不同的量纲，数量级上相差较大，通常需将数据集进行标准化处理，即尽可能让特征分布接近标准正态分布（均值为0，标准差为1）。$$ x' = \frac{x-\mu}{\sigma} $$$\mu$，$\sigma$分别是对应特征下的均值和标准差</p><h4>2. 协方差矩阵</h4><p>协方差矩阵是一个$d \times d$的方阵，是计算两两特征之间的协方差得到的，故是一个对称方阵。$$ C = E[(X-\mu)(X-\mu)^T] $$$\mu$是特征均值向量：$$\mu = E(X) $$</p><h4>3. 协方差矩阵的特征值与特征向量</h4><p>我们计算协方差矩阵的特征值和特征矢量，设d个特征矢量构成特征矩阵$U=[u_1, u_2, ..., u_d]$，d个特征值构成对角矩阵$\Lambda = diag(\lambda_1, \lambda_2, ..., \lambda_d)$，按照线性代数中矩阵特征矢量的定义有：$$ CU = U \Lambda $$于是：$$ C = U \Lambda U^T $$</p><h4>4. 方差贡献率</h4><p>每个主成分有与其对应的本征值，决定这该主成分的方差，方差越大表示该主成分包含的信息越多，方差越小，表示包含的信息越少（通常是数据噪声，但有时这部分成分也包含重要信息）。我们按照方差从大到小排序，选择前k个主成分（通常设定阈值90%，前k个主成分的累积方差贡献率不低于90%）。</p><h4>5. 数据降维</h4><p>选择对应的k个特征向量构成变换矩阵$U_k=[u_1, u_2, ..., u_k]$，将变换矩阵作用在原始数据集上得到降维后的数据集：$$ Y = U_k^T X $$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分箱提高分类模型性能</title>
      <link href="/2019/08/14/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E5%88%86%E7%AE%B1/"/>
      <url>/2019/08/14/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E5%88%86%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回归模型的评估指标</title>
      <link href="/2019/08/02/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/"/>
      <url>/2019/08/02/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>机器学习中回归模型的一些评估指标。</p><a id="more"></a><h4>1. 解释方差（Explained Variance）</h4><p>$$ EV(y, \hat y) = 1 - \frac{Var\{y-\hat y\}}{Var\{y\}} $$</p><h4>2. 均方误差（MSE）</h4><p>$$ MSE(y, \hat y) = \frac{1}{n} \sum_{i=1}^N (\hat y_i - y_i)^2  $$</p><h4>3. 均方根误差（RMSE）</h4><p>$$ RMSE(y, \hat y) = \sqrt{\frac{1}{n} \sum_{i=1}^N (\hat y_i - y_i)^2}  $$</p><h4>4. 平均绝对误差（MAE）</h4><p>$$ MAE(y, \hat y) = \frac{1}{N} \sum_{i=1}^N |\hat y_i - y_i| $$</p><h4>5. 均值平方对数误差（MSLE）</h4><p>$$ MSLE(y, \hat y) = \frac{1}{N} \sum_{i=1}^N (ln(1+y_i)-ln(1+\hat y_i))^2 $$</p><h4>6. 中位数绝对误差（MedianAE）</h4><p>$$ MedAE(y,\hat y) = median(|y_1 - \hat y_1|, ..., |y_n-\hat y_n|) $$</p><h4>7. R方（R Squared）</h4><p>$$ R^2 = 1 - \frac{\sum_{i=1}^N(y_i - \hat y_i)^2}{\sum_{i=1}^N(y_i - \bar y)^2 } $$结果在-1~1之间，如果结果为0，那么模型和猜测差不多，如果为1，说明模型没有误差，如果结果小于0，那么模型还不如随机猜测。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>波士顿房价数据集分析</title>
      <link href="/2019/07/26/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/07/26/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>波士顿房价集来源于1978年美国某经济学杂志。该数据集包含若干波士顿房屋的价格及其各项数据，每个数据项包含14个数据，分别是房屋均价及周边犯罪率、是否在河边等相关信息，其中最后一个数据是房屋均价。</p><a id="more"></a><h4>1. 数据集中有506条数据，13个特征，1个标签，这是一个回归问题。</h4><h4>2. 各个特征字段的说明如下：</h4><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:left">字段</th><th style="text-align:left">字段说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">CRIM</td><td style="text-align:left">城镇人均犯罪率</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">ZN</td><td style="text-align:left">住宅用地所占比例</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">INDUS</td><td style="text-align:left">城镇中非商业用地所占比例</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">CHAS</td><td style="text-align:left">CHAS查尔斯和虚拟变量</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">NOX</td><td style="text-align:left">环保指标(一氧化氮浓度)</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">RM</td><td style="text-align:left">每栋住宅的房间数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">AGE</td><td style="text-align:left">1940年以前建成的自助单位比例</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">DIS</td><td style="text-align:left">距离五个波士顿就业中心的加权距离</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">RAD</td><td style="text-align:left">距离高速公路的便利指数</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">TAX</td><td style="text-align:left">每一万美元的不动产税率</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">PTRATIO</td><td style="text-align:left">城镇中教师学生比例</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">B</td><td style="text-align:left">城镇中黑人比例</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">LSTAT</td><td style="text-align:left">人口中地位低下者的比例</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">MEDV</td><td style="text-align:left">平均房价</td></tr></tbody></table><h4>3. 各特征的取值分布情况</h4><h5>(1) CRIM</h5><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5i5uelkkij30fw099mx4.jpg" alt=""></p><h5>(2) ZN</h5><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5i5wgcp7nj30fw0993yg.jpg" alt=""></p><h5>(3) INDUS</h5><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5i5xvnlopj30fw099wef.jpg" alt=""></p><h5>(4) CHAS</h5><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5i636tp3ej308708o749.jpg" alt=""></p><h5>(5) NOX</h5><p><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5iqwv0k6kj30fp0990sn.jpg" alt=""></p><h5>(6)</h5><h5>(7)</h5><h5>(8)</h5><h5>(9)</h5><h5>(10)</h5><h5>(11)</h5><h5>(12)</h5><h5>(13)</h5><h5>(14)</h5><h4>4. 关联矩阵</h4><div align="center"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5de0yiya8j30bn09rmx4.jpg">关联矩阵</div>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT主题配置教程</title>
      <link href="/2019/07/25/NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2019/07/25/NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建教程</title>
      <link href="/2019/07/25/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2019/07/25/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python查询Solr</title>
      <link href="/2019/07/24/Python%E6%9F%A5%E8%AF%A2Solr/"/>
      <url>/2019/07/24/Python%E6%9F%A5%E8%AF%A2Solr/</url>
      
        <content type="html"><![CDATA[<p>Pysolr是基于Python的Apache Solr轻量级封装。它提供了服务器查询并返回基于查询的结果接口,提供了基本的查询，删除，更新功能。</p><a id="more"></a><ol><li><p><strong>solr请求中返回特定的字段类容</strong></p><p>在web请求报文中按如下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?q=query&amp;fl=field1,field2,field3</span><br></pre></td></tr></table></figure></li><li><p><strong>Python面向对象机制</strong></p><p>&quot;单下划线&quot; 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量</p><p>&quot;双下划线&quot; 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据</p><p>以双下划线开头和结尾的代表python里特殊方法专用的标识</p><p>_xxx 不能用 <code>from moduleimport *</code> 导入</p><p>__xxx 类中的私有变量名</p><p>__xxx__ 系统定义名字</p><p>核心风格：避免用下划线作为变量名的开始</p><p>python中并没有类似其他面向对象语言的<strong>private</strong>和<strong>public</strong>属性，无法在语言层面上用语言特性去封装数据。python用对属性和方法的<strong>命名约定</strong>来实现数据封装。</p><ul><li>单下划线_开头的属性和方法属于类的私有成员，在模块或类外不可以使用。</li><li>双划线__开头的函数会导致访问名称变成其他形式，主要目的是为了将某个属性在子类中隐藏起来</li></ul></li><li><p>Pysolr的基本机制</p><p>pysolr对web请求进一步封装，封装了对solr索引库的增删改查操作。这里，我们的主要需求是对solr索引库的查找操作，仅涉及到pysolr的查询命令，因此对pysolr的查询进一步封装，使得查询操作尽可能简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pysolr</span><br><span class="line">solr = pysolr.Solr(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line">res = solr.search(params)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene - Query Parser Syntax</title>
      <link href="/2019/07/24/Lucene%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/07/24/Lucene%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。Lucene最初是由Doug Cutting开发的，在SourceForge的网站上提供下载。在2001年9月作为高质量的开源Java产品加入到Apache软件基金会的Jakarta家族中。</p><a id="more"></a><ol><li><p>Lucene提供一个查询解析器，可以将字符串解释成Lucene查询语句。</p></li><li><p>不同发行版的Lucene其查询解析器的语法稍有不同，以各版本为主。</p></li><li><p>不建议以程序生成查询字符串，查询字符串的设计初衷是方便人工输入查询，若需要程序生成查询字符串，建议使用Lucene的查询API。</p></li></ol><h4>一. 查询字符串</h4><p>查询语句可分为<strong>词语</strong>（terms）和<strong>操作符</strong>（operators）,多个词语可以通过操作符形成更加复杂的搜索逻辑</p><h4>二. 对单词（single terms）和语句（phrases）查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单词： &quot;hello&quot;, &quot;world&quot;  </span><br><span class="line">语句： &quot;hello world&quot;</span><br></pre></td></tr></table></figure><h4>三. 对某个字段进行搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title:hello  </span><br><span class="line">title:&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>Lucene中可定义默认字段，如默认字段是text，若匹配text字段下的go时，不需要指定字段名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:hello AND go</span><br></pre></td></tr></table></figure><p>它与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: hello AND text:go</span><br></pre></td></tr></table></figure><p>是等价的。</p><h4>四. 通过修饰符进行查找</h4><p>可以在单个单词或者语句中添加通配符：</p><ul><li><code>?</code>匹配单个字符</li><li><code>*</code>匹配0个或多个字符<br><strong>注意</strong>：一些版本中，不支持将通配符放在搜索的开头</li></ul><h4>五. 模糊词查询（Fuzzy Searches）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt;想要搜索和test相近的词</span><br><span class="line">test~</span><br><span class="line">可以搜索出text或者tests等词</span><br></pre></td></tr></table></figure><p>支持在~后面添加模糊系数，模糊系数[0-1]，越靠近1表示越相近,默认模糊系数为0.5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test~0.8</span><br></pre></td></tr></table></figure><h4>六. 邻近词查询（Proximity Searches）</h4><p>前面的模糊词只是针对某个单词，在语句间也存在模糊搜索的概念，只不过不是单词的模糊，而是单词之间内容的模糊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;想要搜索包含&quot;hello&quot;&quot;world&quot;的文档，这两个单词中间可以有一部分内容（这部分内容通过字符个数限制）</span><br><span class="line">&quot;hello world&quot;~10</span><br><span class="line">可以匹配&quot;hello 123 world&quot;</span><br><span class="line">或者&quot;hello,Tom,world&quot;</span><br></pre></td></tr></table></figure><h4>七. 范围查询（Range Searches）</h4><p>支持范围搜索，可以指定最小值和最大值，会自动查找在这之间的文档。如果是单词，则会按照字典顺序搜索。</p><ul><li><code>{}</code>尖括号表示不包含最小值和最大值，可以单独使用</li><li><code>[]</code>方括号表示包含最小值和最大值，可以单独使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;搜索成绩grade字段小于等于80分，大于60分的</span><br><span class="line">grade:&#123;60,80]</span><br><span class="line">-&gt;搜索名字在A和C之间的</span><br><span class="line">name:&#123;A,C&#125;</span><br><span class="line">返回，bone、baby、barry</span><br></pre></td></tr></table></figure><h4>八. 词语相关度查询（Boosting a Term）</h4><p>如果单词的匹配度很高，一个文档中或者一个字段中可以匹配多次，那么可以提升该词的相关度。使用符号<code>^</code>提高相关度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt;提高jarkarta的比重</span><br><span class="line">jakarta apache</span><br></pre></td></tr></table></figure><p>可以使用下面语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jakarta^4 apache</span><br></pre></td></tr></table></figure><h4>九. 布尔操作符（Boolean Operator）</h4><ol><li><p><strong>AND</strong>AND操作符用于连接两个搜索条件，仅当两个搜索条件都满足时，才认为匹配。通常用来做交集操作。也可以使用<code>&amp;&amp;</code>替换。注意必须使用大写。如果不使用AND，而是and，可能会被单做关键词进行搜索！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;搜索同时包含tom和john的文档</span><br><span class="line">tom AND john</span><br><span class="line">或者</span><br><span class="line">tom &amp;&amp; john</span><br></pre></td></tr></table></figure></li><li><p><strong>OR</strong>OR操作符用于连接两个搜索条件，当其中一个条件满足时，就认为匹配。通常用来做并集操作。也可以使用<code>||</code>替换。注意必须使用大写。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;搜索包含tom或者john的文档</span><br><span class="line">tom OR john</span><br><span class="line">或者</span><br><span class="line">tom || john</span><br></pre></td></tr></table></figure></li><li><p><strong>NOT</strong>NOT操作符排除某个搜索条件。通常用来做差集操作也可以使用<code>!</code>替换。注意必须大写。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;搜索包含tom，不包含john的文档</span><br><span class="line">tom NOT john</span><br><span class="line">或者</span><br><span class="line">tom &amp;&amp; !john</span><br></pre></td></tr></table></figure></li><li><p><strong>+</strong><strong>包含</strong>该操作符后跟着的搜索条件，作用和AND的差不多，但是支持单独使用如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt;搜索包含tom的文档</span><br><span class="line">+tom</span><br></pre></td></tr></table></figure></li><li><p><strong>-</strong><strong>排除</strong>该操作符后跟着的搜索条件，效果类似NOT，如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt;搜索不包含tom的文档</span><br><span class="line">-tom</span><br></pre></td></tr></table></figure></li><li><p>分组（Grouping）支持使用小括号对每个子句进行分组，形成更为复杂的查询逻辑。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt;要搜索包含hello的文档中，也包含tom或者john的</span><br><span class="line">hello AND (tom OR john)</span><br></pre></td></tr></table></figure></li><li><p>转义字符（Escaping Special Character）由于Lucene中支持很多的符号，如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - &amp;&amp; || ! ( ) &#123; &#125; [ ] ^ &quot; ~ * ? : \</span><br></pre></td></tr></table></figure><p>因此如果需要搜索<code>(1+1):2</code>需要对改串进行转换，使用字符<code>\</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\(1\+1\)\:2</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr使用教程</title>
      <link href="/2019/07/17/Solr%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/07/17/Solr%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>能够检索相关信息是许多应用的基本要求，一些开发者和架构师通过复杂的SQL请求来检索数据在非关系型数据中进行检索</p><p>Solr可以作为一个搜索引擎使用</p><p>Apache Solr是一个流行的，快速的，开源的企业级搜索平台，应用在很多大型网站中。</p><p>Apache Solr安装有Java依赖，安装前先配置好java环境变量。</p><blockquote><ol><li>从Solr官网下载二进制安装包</li><li>解压包，进步bin目录</li><li>执行sudo bash ./install_solr_service.sh solr.zip -i /opt -d /var/solr -u solr -s solr -p 8983<br>安装脚本只认tgz和zip文件，若已经安装过solr，需加-f参数表示更新solr。</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python读取导出json格式数据文件</title>
      <link href="/2019/05/15/Python%E8%AF%BB%E5%8F%96%E5%AF%BC%E5%87%BAjson%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/05/15/Python%E8%AF%BB%E5%8F%96%E5%AF%BC%E5%87%BAjson%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、Java、JavaScript、Perl、Python 等)。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p><a id="more"></a><p>在Python中有默认的模块实现json数据的导入导出。</p><ol><li><p>导入json模块</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure></li><li><p>将Python字典转换为字符串</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义一个python字典数据</span></span><br><span class="line">test_dict = &#123;<span class="string">'bigberg'</span>: [<span class="number">7600</span>, &#123;<span class="number">1</span>: [[<span class="string">'iPhone'</span>, <span class="number">6300</span>], [<span class="string">'Bike'</span>, <span class="number">800</span>], [<span class="string">'shirt'</span>, <span class="number">300</span>]]&#125;]&#125;</span><br><span class="line"><span class="comment"># 将字典转换为json字符串</span></span><br><span class="line">json_str = json.dumps(test_dict)</span><br></pre></td></tr></table></figure></li><li><p>将字符串转换为Python字典</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将json字符串还原为字典</span></span><br><span class="line">new_dict = json.loads(json_str)</span><br></pre></td></tr></table></figure></li><li><p>将Python字典写入json格式文件中</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字典new_dict中的数据写入json格式文件中</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"record.json"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(new_dict,f)</span><br></pre></td></tr></table></figure></li><li><p>从json格式文件中导入数据到Python字典</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"record.json"</span>,<span class="string">'r'</span>) <span class="keyword">as</span> load_f:</span><br><span class="line">    load_dict = json.load(load_f)</span><br><span class="line">    print(load_dict)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型</title>
      <link href="/2018/08/23/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/23/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4>一. 基本形式</h4><p>由$d$个属性描述的实例$x=(x_1; x_2; ...; x_d)$，线性回归试图学得一个通过属性的线性组合来预测的函数：</p><p>$$ f(x)=w_1 x_1 + w_2 x_2 + ... + w_d x_d + b $$</p><a id="more"></a><p>向量形式写成：</p><p>$ f(x)=w^T x+b$ ，其中 $w = (w_1; w_2; ...; w_d)$</p><h4>二. 线性回归</h4><p>设样本集的数目为$m$，$x$代表输入变量（特征），$y$代表输出变量（目标），$(x,y)$代表样本集中的实例，$(x^i,y^i)$代表样本集中第$i$个实例，函数$f(x)$是模型的假设。</p><h5>1. 损失函数</h5><p>模型的参数$w, b$决定模型预测能力的好坏，模型在训练集中的预测值与实际值的差距是我们的建模误差，代价函数即定义为建模误差的平方和：</p><p>$ J(w, b) = \frac{1}{2m} \sum_{i=1}^{m}(f(x^i)-y^i)^2 $</p><p>我们的目标是选择使代价函数最小的模型参数。</p><h5>2. 梯度下降法</h5><p>$w = w - \alpha \frac{\partial}{\partial w}J(w,b)$</p><p>$b = b - \alpha \frac{\partial}{\partial b}J(w,b)$</p><p>$\alpha$ 是学习率</p><p>$\frac{\partial}{\partial b}J(w,b) = \frac{1}{m}\sum_{i=1}^{m}(f(x^i)-y^i)$</p><p>$\frac{\partial}{\partial w}J(w,b) = \frac{1}{m}\sum_{i=1}^{m}((f(x^i)-y^i) x^i)$</p><h5>3. 最小二乘法</h5><h4>三. 逻辑回归</h4><p>逻辑回归用来处理$y$值是离散情况的分类问题。</p><h5>1. 分类问题</h5><h5>2. 假说表示</h5><h5>3. 判定边界</h5><h5>4. 代价函数与梯度下降</h5><h4>四. 正则化</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNIST数据集</title>
      <link href="/2018/08/23/MNIST%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>/2018/08/23/MNIST%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>MNIST 数据集</strong>可在 <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="external">http://yann.lecun.com/exdb/mnist/</a> 获取，它包含了四个部分：</p><a id="more"></a><ul><li><p><strong>Training set images：</strong></p><p>train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</p></li><li><p><strong>Training set labels：</strong></p><p>train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</p></li><li><p><strong>Test set images：</strong></p><p>t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</p></li><li><p><strong>Test set labels：</strong></p><p>t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</p></li></ul><p>MNIST 数据集来自美国国家标准与技术研究所，<strong>National Institute of Standards and Technology (NIST)</strong>，训练集 (training set) 由来自 250 个不同人手写的数字构成，其中 50% 是高中学生，50% 来自人口普查局 (the Census Bureau) 的工作人员。测试集(test set) 也是同样比例的手写数字数据。</p><p>图片是以字节的形式进行存储, 我们需要把它们读取到 NumPy array 中，以便训练和测试算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_mnist</span><span class="params">(path, kind=<span class="string">'train'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Load MNIST data from `path`"""</span></span><br><span class="line">    labels_path = os.path.join(path,</span><br><span class="line">                               <span class="string">'%s-labels-idx1-ubyte'</span></span><br><span class="line">                               % kind)</span><br><span class="line">    images_path = os.path.join(path,</span><br><span class="line">                               <span class="string">'%s-images-idx3-ubyte'</span></span><br><span class="line">                               % kind)</span><br><span class="line">    <span class="keyword">with</span> open(labels_path, <span class="string">'rb'</span>) <span class="keyword">as</span> lbpath:</span><br><span class="line">        magic, n = struct.unpack(<span class="string">'&gt;II'</span>,</span><br><span class="line">                                 lbpath.read(<span class="number">8</span>))</span><br><span class="line">        labels = np.fromfile(lbpath,</span><br><span class="line">                             dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(images_path, <span class="string">'rb'</span>) <span class="keyword">as</span> imgpath:</span><br><span class="line">        magic, num, rows, cols = struct.unpack(<span class="string">'&gt;IIII'</span>,</span><br><span class="line">                                               imgpath.read(<span class="number">16</span>))</span><br><span class="line">        images = np.fromfile(imgpath,</span><br><span class="line">                             dtype=np.uint8).reshape(len(labels), <span class="number">784</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images, labels</span><br></pre></td></tr></table></figure><p><code>load_mnist</code> 函数返回两个数组，第一个是一个 n x m 维的 NumPy array(<code>images</code>)，这里的 n 是样本数(行数)，m 是特征数(列数)。训练数据集包含 60000 个样本，测试数据集包含 10000 样本。在 MNIST 数据集中的每张图片由 28 x 28 个像素点构成，每个像素点用一个灰度值表示。在这里, 我们将 28 x 28 的像素展开为一个一维的行向量，这些行向量就是图片数组里的行(每行 784 个值，或者说每行就是代表了一张图片)。 <code>load_mnist</code> 函数返回的第二个数组(<code>labels</code>) 包含了相应的目标变量，也就是手写数字的类标签(整数 0-9)。</p><p>通过执行上面的代码，我们将会从刚刚解压 MNIST 数据集后的 mnist 目录下加载 60000 个训练样本和 10000 个测试样本。</p><p>为了了解 MNIST 中的图片看起来到底是个啥，让我们来对它们进行可视化处理。从 feature matrix 中将 784-像素值的向量 reshape 为之前的 28*28 的形状，然后通过 matplotlib 的 <code>imshow</code> 函数进行绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(</span><br><span class="line">    nrows=<span class="number">2</span>,</span><br><span class="line">    ncols=<span class="number">5</span>,</span><br><span class="line">    sharex=<span class="keyword">True</span>,</span><br><span class="line">    sharey=<span class="keyword">True</span>, )</span><br><span class="line"></span><br><span class="line">ax = ax.flatten()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    img = X_train[y_train == i][<span class="number">0</span>].reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    ax[i].imshow(img, cmap=<span class="string">'Greys'</span>, interpolation=<span class="string">'nearest'</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_xticks([])</span><br><span class="line">ax[<span class="number">0</span>].set_yticks([])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>此外，我们还可以绘制某一数字的多个样本图片，来看一下这些手写样本到底有多不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(</span><br><span class="line">    nrows=<span class="number">5</span>,</span><br><span class="line">    ncols=<span class="number">5</span>,</span><br><span class="line">    sharex=<span class="keyword">True</span>,</span><br><span class="line">    sharey=<span class="keyword">True</span>, )</span><br><span class="line"></span><br><span class="line">ax = ax.flatten()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">    img = X_train[y_train == <span class="number">7</span>][i].reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    ax[i].imshow(img, cmap=<span class="string">'Greys'</span>, interpolation=<span class="string">'nearest'</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_xticks([])</span><br><span class="line">ax[<span class="number">0</span>].set_yticks([])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Pandas模块读取csv格式文件</title>
      <link href="/2018/08/22/%E4%BD%BF%E7%94%A8Pandas%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%8F%96csv%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/22/%E4%BD%BF%E7%94%A8Pandas%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%8F%96csv%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在数据处理中，常遇到csv格式的文件，下面简要介绍如何使用Python中的Pandas模块来读取csv文件中的数据。</p><a id="more"></a><h2>一. CSV文件</h2><p>CSV(Comma-Separated Values)文件以纯文本形式存储表格数据，文件由任意数目的记录组成，记录间以换行符分隔，每条记录由字段组成，字段间的分隔符可自定义，通常是逗号。下面的数据取自Kaggle中Titanic的乘客信息数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PassengerId,Pclass,Name,Sex,Age,SibSp,Parch,Ticket,Fare,Cabin,Embarked</span><br><span class="line">892,3,&quot;Kelly, Mr. James&quot;,male,34.5,0,0,330911,7.8292,,Q</span><br><span class="line">893,3,&quot;Wilkes, Mrs. James (Ellen Needs)&quot;,female,47,1,0,363272,7,,S</span><br><span class="line">894,2,&quot;Myles, Mr. Thomas Francis&quot;,male,62,0,0,240276,9.6875,,Q</span><br><span class="line">895,3,&quot;Wirz, Mr. Albert&quot;,male,27,0,0,315154,8.6625,,S</span><br><span class="line">896,3,&quot;Hirvonen, Mrs. Alexander (Helga E Lindqvist)&quot;,female,22,1,1,3101298,12.2875,,S</span><br><span class="line">897,3,&quot;Svensson, Mr. Johan Cervin&quot;,male,14,0,0,7538,9.225,,S</span><br><span class="line">898,3,&quot;Connolly, Miss. Kate&quot;,female,30,0,0,330972,7.6292,,Q</span><br><span class="line">899,2,&quot;Caldwell, Mr. Albert Francis&quot;,male,26,1,1,248738,29,,S</span><br><span class="line">900,3,&quot;Abrahim, Mrs. Joseph (Sophie Halaut Easu)&quot;,female,18,0,0,2657,7.2292,,C</span><br><span class="line">901,3,&quot;Davies, Mr. John Samuel&quot;,male,21,2,0,A/4 48871,24.15,,S</span><br></pre></td></tr></table></figure><h2>二. Pandas模块</h2><ol><li><p>导入pandas模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure></li><li><p>读取csv文件中的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">"train.csv"</span>,sep=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p>参数<code>sep</code>设定csv文件中分隔符，默认为<code>,</code>。</p></li><li><p>数据集对应的参数名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.columns</span><br></pre></td></tr></table></figure></li><li><p>第 $i$ 条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[i-1]</span><br></pre></td></tr></table></figure></li><li><p>数据集的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.shape</span><br></pre></td></tr></table></figure></li><li><p>数据集的描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.describe</span><br></pre></td></tr></table></figure></li><li><p>数据集参数数组里的不同值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic[<span class="string">'Sex'</span>].unique()</span><br></pre></td></tr></table></figure></li><li><p>数据集字符串到数字的映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic.loc[titanic[<span class="string">'Sex'</span>]==<span class="string">'male'</span>,<span class="string">'Sex'</span>]=<span class="number">0</span></span><br><span class="line">titanic.loc[titanic[<span class="string">'Sex'</span>]==<span class="string">'female'</span>,<span class="string">'Sex'</span>]=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>数据集中缺失数据的补填</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic[<span class="string">'Age'</span>]=titanic[<span class="string">'Age'</span>].fillna(titanic[<span class="string">'Age'</span>].median())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
