<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran&#39;s Homepage</title>
  
  <subtitle>Notes about program, math and life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-08T18:00:07.781Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ran Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时间数据类型处理</title>
    <link href="http://yoursite.com/2019/12/24/%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/24/%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86/</id>
    <published>2019-12-24T06:18:06.000Z</published>
    <updated>2020-01-08T18:00:07.781Z</updated>
    
    <content type="html"><![CDATA[<p>编写Python程序处理数据时，常遇到时间格式的字符串数据，有时涉及到时间的加减运算。在Python中，有专门的时间结构的数据对象来表示时间数据，实际中，我们常喜欢用字符串数据来表示时间，或者整型的时间戳。因此常涉及这三种时间数据类型的转换操作。</p><a id="more"></a><p><img src="https://wx1.sinaimg.cn/mw690/714d7887ly1gapnyyktzaj20d209ndgs.jpg" alt></p><h3>获取当前时间戳</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seconds = time.time()</span><br></pre></td></tr></table></figure><h3>时间戳格式转时间格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = time.localtime(seconds)</span><br></pre></td></tr></table></figure><h3>时间格式转字符串格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time)</span><br></pre></td></tr></table></figure><h3>时间戳转换为字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime(seconds))</span><br></pre></td></tr></table></figure><h3>字符串转换为时间戳</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.mktime(time.strptime(<span class="string">"2018-08-07"</span>, <span class="string">"%Y-%m-%d"</span>))</span><br></pre></td></tr></table></figure><blockquote><p>[1] lwb444:<a href="https://www.cnblogs.com/linwenbin/p/10905341.html" target="_blank" rel="noopener">《Python 时间戳/字符串/时间 转换》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写Python程序处理数据时，常遇到时间格式的字符串数据，有时涉及到时间的加减运算。在Python中，有专门的时间结构的数据对象来表示时间数据，实际中，我们常喜欢用字符串数据来表示时间，或者整型的时间戳。因此常涉及这三种时间数据类型的转换操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>核主成分分析</title>
    <link href="http://yoursite.com/2019/10/24/%E6%A0%B8%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/24/%E6%A0%B8%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</id>
    <published>2019-10-24T09:06:46.000Z</published>
    <updated>2020-01-08T18:01:25.767Z</updated>
    
    <content type="html"><![CDATA[<p>在核主成分分析中，我们认为原始数据集有更高的维数，我们可以在更高维的空间中做PCA分析（即在更高维空间里，把原始数据向不同的方向投影）。原因在于：在低维空间难以线性分类的数据点，我们有可能再更高维度上找到合适的高维线性分类平面。</p><a id="more"></a><h4>一. 核函数</h4><h5>1. 核函数的定义</h5><p>假设输入空间为X，特征空间为F（特征空间具有很高的维数，甚至无穷维），存在一个映射$\phi$将空间X中的点x映射到空间F中的点f：$$ \phi(x): X \rightarrow F $$实际应用中，我们难以确定映射$\phi$的具体形式，然而我们的主要计算需求是计算两个向量的内积，通过引入核函数，我们不需要知道映射的具体形式，便可通过低维空间的向量来计算高维空间向量的内积。<br>设：$x$，$z$是低维空间任意两个向量，那么核函数满足下述关系：$$ K(x,z) = \phi(x) \cdot \phi(z) $$</p><p>比如我们定义如下二维到三维的映射函数（这里，$x_i$表示样本$x$的第$i$个分量）：$$ \phi(x) = (x_1^2, \sqrt{2} x_1 x_2, x_2^2) $$可以验证：$$ K(x,z) = \phi(x) \cdot \phi(z) = (x \cdot z)^2 $$</p><h5>2. 核矩阵</h5><p>任意两个样本点映射到高维空间后的内积组成的矩阵称为核函数矩阵（这里，$x_i$表示第$i$个样本）：$$\begin{bmatrix}\phi(x_1) \cdot \phi(x_1) &amp; ... &amp; \phi(x_1) \cdot \phi(x_N) \\...                       &amp; ... &amp; ... \\\phi(x_N) \cdot \phi(x_1) &amp; ... &amp; \phi(x_N) \cdot \phi(x_N)\end{bmatrix}$$</p><p>常用的核函数的形式有如下几种：</p><h6>(1) 线性核</h6><p>$$ K(x,z) = x \cdot z $$</p><h6>(2) 多项式核</h6><p>$$ K(x,z) = (x \cdot z + 1)^r, r \in Z $$</p><h6>(3) 高斯核</h6><p>$$ K(x,z) = exp(-\frac{|x-z|^2}{2\sigma^2}), \sigma \in R, and\ \sigma \neq 0$$</p><p>采用核函数避免直接将原始向量映射到高维空间进行内积计算，一方面避开了映射函数的寻找，另一方面也减少了运算量。不过如果映射后的空间维数过高，导致模型在训练集上过拟合，在测试集上的泛化能力往往不加。</p><h4>二. 核技巧</h4><p>与线性主成分分析不同，核主成分分析通过在高维有映射后的特征空间进行主成分分析，设我们的原始数据矩阵为$X$：$$ [x_1, x_2, ..., x_N] $$$x_i$表示数据集中的第$i$个样本，是一个维度为$d$的列向量，这里矩阵的每一列为一个样本，样本数为$N$。我们通过映射函数$\phi(x)$将所有样本映射到维度为$D$的特征空间$F$，映射后的数据矩阵为$\phi(X)$：$$ [\phi(x_1), \phi(x_2), ..., \phi(x_N)] $$接下来对数据集$\phi(X)$进行PCA处理，这里预先假设$\phi(X)$已经经过中心化处理：$$ \sum_{i}^{N} \phi(x_i) = 0 $$在特征空间里，数据集$\phi(X)$的协方差矩阵为：$$ C_F = \frac{1}{N} \phi(X) \phi(X)^T = \frac{1}{N} \sum_{i=1}^N \phi(x_i) \phi(x_i)^T $$PCA计算实质是求解协方差矩阵$C_F$的本征值问题：$$ C_F p = \lambda p $$即：$$ \sum_{i=1}^N \phi(x_i) \phi(x_i)^T p = \lambda p $$这里不考虑因子$\frac{1}{N}$<br>降维时我们考虑的是本征值$\lambda \neq 0$的成分，我们对上式两边同消去$\lambda$，得到：$$ p = \sum_{i=1}^N \phi(x_i) [ \phi(x_i)^T p ] $$注意到上式方括号中的值是一个常数，我们用$\alpha_i$代替，于是：$$ p = \sum_{i=1}^N \alpha_i \phi(x_i) = \phi(X) \alpha $$$\alpha$是一个$N$维的向量：$[\alpha_1, \alpha_2, ..., \alpha_N]^T $<br>这里得到一个结论：特征值不为0的特征向量可表示为高维空间样本向量的线性组合。<br>将上式带入$C_F$的本征方程中得：$$ \phi(X)^T \phi(X) \phi(X)^T \phi(X) \alpha = \lambda \phi(X)^T \phi(X) \alpha $$定义核函数矩阵为：$K=\phi(X)^T \phi(X)$，上式化简为：$$ K \cdot K \alpha = \lambda K \alpha $$参考文献[1]证明为求解上式，则只需求解下述本征方程，该本征方程的特征值即原问题的本征值。$$ K \alpha = \lambda \alpha $$</p><blockquote><p>[1] B. Scholkopf, A. J. Smola, K. Muller. Nonlinear component analysis as a kernel eigenvalue problem. Neural Computation 10 (5), 1299–1399, 1998.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在核主成分分析中，我们认为原始数据集有更高的维数，我们可以在更高维的空间中做PCA分析（即在更高维空间里，把原始数据向不同的方向投影）。原因在于：在低维空间难以线性分类的数据点，我们有可能再更高维度上找到合适的高维线性分类平面。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>主成分分析</title>
    <link href="http://yoursite.com/2019/10/24/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/24/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</id>
    <published>2019-10-24T08:14:19.000Z</published>
    <updated>2020-01-08T18:01:18.383Z</updated>
    
    <content type="html"><![CDATA[<p>主成分分析是数据降维的重要手段，当样本中包含多个特征且特征之间强耦合时，将强耦合的特征综合成一个或几个特征，这样既减少了样本的维度，节约计算资源也减少过拟合的风险。在主成分分析中，每一个主成分都是数据集在某一个方向上的投影，不同方向上数据集的方差(variance)由该方向上的特征值(eigenvalue)决定，一般我们选择最大的几个特征值所在的特征向量(eigenvector)，认为在这些方向上，数据集包含了我们所需要的信息。</p><a id="more"></a><h4>1. 数据集标准化</h4><p>假设我们有一个数据集，每个样本有d个特征，共N个样本，我们构建一个$d \times N$维的矩阵$X = [x_1, x_2, ..., x_N]$，矩阵的每一列对应一个样本，矩阵的每一行对应一个特征。</p><p>由于数据集中的每个特征来源于不同的变量，往往具有不同的量纲，数量级上相差较大，通常需将数据集进行标准化处理，即尽可能让特征分布接近标准正态分布（均值为0，标准差为1）。$$ x' = \frac{x-\mu}{\sigma} $$$\mu$，$\sigma$分别是对应特征下的均值和标准差</p><h4>2. 协方差矩阵</h4><p>协方差矩阵是一个$d \times d$的方阵，是计算两两特征之间的协方差得到的，故是一个对称方阵。$$ C = E[(X-\mu)(X-\mu)^T] $$$\mu$是特征均值向量：$$\mu = E(X) $$</p><h4>3. 协方差矩阵的特征值与特征向量</h4><p>我们计算协方差矩阵的特征值和特征矢量，设d个特征矢量构成特征矩阵$U=[u_1, u_2, ..., u_d]$，d个特征值构成对角矩阵$\Lambda = diag(\lambda_1, \lambda_2, ..., \lambda_d)$，按照线性代数中矩阵特征矢量的定义有：$$ CU = U \Lambda $$于是：$$ C = U \Lambda U^T $$</p><h4>4. 方差贡献率</h4><p>每个主成分有与其对应的本征值，决定这该主成分的方差，方差越大表示该主成分包含的信息越多，方差越小，表示包含的信息越少（通常是数据噪声，但有时这部分成分也包含重要信息）。我们按照方差从大到小排序，选择前k个主成分（通常设定阈值90%，前k个主成分的累积方差贡献率不低于90%）。</p><h4>5. 数据降维</h4><p>选择对应的k个特征向量构成变换矩阵$U_k=[u_1, u_2, ..., u_k]$，将变换矩阵作用在原始数据集上得到降维后的数据集：$$ Y = U_k^T X $$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主成分分析是数据降维的重要手段，当样本中包含多个特征且特征之间强耦合时，将强耦合的特征综合成一个或几个特征，这样既减少了样本的维度，节约计算资源也减少过拟合的风险。在主成分分析中，每一个主成分都是数据集在某一个方向上的投影，不同方向上数据集的方差(variance)由该方向上的特征值(eigenvalue)决定，一般我们选择最大的几个特征值所在的特征向量(eigenvector)，认为在这些方向上，数据集包含了我们所需要的信息。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>特征工程</title>
    <link href="http://yoursite.com/2019/08/14/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E5%88%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2019/08/14/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E5%88%86%E7%AE%B1/</id>
    <published>2019-08-14T08:54:07.000Z</published>
    <updated>2020-01-08T17:47:16.972Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>回归模型的评估指标</title>
    <link href="http://yoursite.com/2019/08/02/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/2019/08/02/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</id>
    <published>2019-08-02T06:47:01.000Z</published>
    <updated>2019-08-02T07:14:55.833Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习中回归模型的一些评估指标。</p><a id="more"></a><h4>1. 解释方差（Explained Variance）</h4><p>$$ EV(y, \hat y) = 1 - \frac{Var\{y-\hat y\}}{Var\{y\}} $$</p><h4>2. 均方误差（MSE）</h4><p>$$ MSE(y, \hat y) = \frac{1}{n} \sum_{i=1}^N (\hat y_i - y_i)^2  $$</p><h4>3. 均方根误差（RMSE）</h4><p>$$ RMSE(y, \hat y) = \sqrt{\frac{1}{n} \sum_{i=1}^N (\hat y_i - y_i)^2}  $$</p><h4>4. 平均绝对误差（MAE）</h4><p>$$ MAE(y, \hat y) = \frac{1}{N} \sum_{i=1}^N |\hat y_i - y_i| $$</p><h4>5. 均值平方对数误差（MSLE）</h4><p>$$ MSLE(y, \hat y) = \frac{1}{N} \sum_{i=1}^N (ln(1+y_i)-ln(1+\hat y_i))^2 $$</p><h4>6. 中位数绝对误差（MedianAE）</h4><p>$$ MedAE(y,\hat y) = median(|y_1 - \hat y_1|, ..., |y_n-\hat y_n|) $$</p><h4>7. R方（R Squared）</h4><p>$$ R^2 = 1 - \frac{\sum_{i=1}^N(y_i - \hat y_i)^2}{\sum_{i=1}^N(y_i - \bar y)^2 } $$结果在-1~1之间，如果结果为0，那么模型和猜测差不多，如果为1，说明模型没有误差，如果结果小于0，那么模型还不如随机猜测。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习中回归模型的一些评估指标。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>波士顿房价数据分析</title>
    <link href="http://yoursite.com/2019/07/26/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/26/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2019-07-26T08:09:46.000Z</published>
    <updated>2020-01-08T17:55:40.194Z</updated>
    
    <content type="html"><![CDATA[<p>波士顿房价集来源于1978年美国某经济学杂志。该数据集包含若干波士顿房屋的价格及其各项数据，每个数据项包含14个数据，分别是房屋均价及周边犯罪率、是否在河边等相关信息，其中最后一个数据是房屋均价。</p><a id="more"></a><h4>数据集中有506条数据，13个特征，1个标签，这是一个回归问题。</h4><h4>各个特征字段的说明如下：</h4><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:left">字段</th><th style="text-align:left">字段说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">CRIM</td><td style="text-align:left">城镇人均犯罪率</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">ZN</td><td style="text-align:left">住宅用地所占比例</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">INDUS</td><td style="text-align:left">城镇中非商业用地所占比例</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">CHAS</td><td style="text-align:left">CHAS查尔斯和虚拟变量</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">NOX</td><td style="text-align:left">环保指标(一氧化氮浓度)</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">RM</td><td style="text-align:left">每栋住宅的房间数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">AGE</td><td style="text-align:left">1940年以前建成的自助单位比例</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">DIS</td><td style="text-align:left">距离五个波士顿就业中心的加权距离</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">RAD</td><td style="text-align:left">距离高速公路的便利指数</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">TAX</td><td style="text-align:left">每一万美元的不动产税率</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">PTRATIO</td><td style="text-align:left">城镇中教师学生比例</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">B</td><td style="text-align:left">城镇中黑人比例</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">LSTAT</td><td style="text-align:left">人口中地位低下者的比例</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">MEDV</td><td style="text-align:left">平均房价</td></tr></tbody></table><h4>各特征的取值分布情况</h4><h5>(1) CRIM</h5><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5i5uelkkij30fw099mx4.jpg" alt></p><h5>(2) ZN</h5><p><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5i5wgcp7nj30fw0993yg.jpg" alt></p><h5>(3) INDUS</h5><p><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5i5xvnlopj30fw099wef.jpg" alt></p><h5>(4) CHAS</h5><p><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5i636tp3ej308708o749.jpg" alt></p><h5>(5) NOX</h5><p><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5iqwv0k6kj30fp0990sn.jpg" alt></p><h5>(6)</h5><h5>(7)</h5><h5>(8)</h5><h5>(9)</h5><h5>(10)</h5><h5>(11)</h5><h5>(12)</h5><h5>(13)</h5><h5>(14)</h5><h4>关联矩阵</h4><div align="center"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5de0yiya8j30bn09rmx4.jpg">关联矩阵</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;波士顿房价集来源于1978年美国某经济学杂志。该数据集包含若干波士顿房屋的价格及其各项数据，每个数据项包含14个数据，分别是房屋均价及周边犯罪率、是否在河边等相关信息，其中最后一个数据是房屋均价。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Analysis" scheme="http://yoursite.com/categories/Data-Analysis/"/>
    
    
  </entry>
  
  <entry>
    <title>NexT主题配置教程</title>
    <link href="http://yoursite.com/2019/07/25/NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/25/NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</id>
    <published>2019-07-25T09:19:31.000Z</published>
    <updated>2019-07-25T09:19:31.094Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建教程</title>
    <link href="http://yoursite.com/2019/07/25/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/25/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2019-07-25T09:19:15.000Z</published>
    <updated>2019-07-25T09:19:15.624Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>json格式文件的导入与导出</title>
    <link href="http://yoursite.com/2019/05/15/json%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2019/05/15/json%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/</id>
    <published>2019-05-15T06:38:23.000Z</published>
    <updated>2020-01-08T17:59:20.462Z</updated>
    
    <content type="html"><![CDATA[<p>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、Java、JavaScript、Perl、Python 等)。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p><a id="more"></a><p>在Python中有默认的模块实现json数据的导入导出。</p><ol><li><p>导入json模块</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure></li><li><p>将Python字典转换为字符串</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义一个python字典数据</span></span><br><span class="line">test_dict = &#123;<span class="string">'bigberg'</span>: [<span class="number">7600</span>, &#123;<span class="number">1</span>: [[<span class="string">'iPhone'</span>, <span class="number">6300</span>], [<span class="string">'Bike'</span>, <span class="number">800</span>], [<span class="string">'shirt'</span>, <span class="number">300</span>]]&#125;]&#125;</span><br><span class="line"><span class="comment"># 将字典转换为json字符串</span></span><br><span class="line">json_str = json.dumps(test_dict)</span><br></pre></td></tr></table></figure></li><li><p>将字符串转换为Python字典</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将json字符串还原为字典</span></span><br><span class="line">new_dict = json.loads(json_str)</span><br></pre></td></tr></table></figure></li><li><p>将Python字典写入json格式文件中</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字典new_dict中的数据写入json格式文件中</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"record.json"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(new_dict,f)</span><br></pre></td></tr></table></figure></li><li><p>从json格式文件中导入数据到Python字典</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"record.json"</span>,<span class="string">'r'</span>) <span class="keyword">as</span> load_f:</span><br><span class="line">    load_dict = json.load(load_f)</span><br><span class="line">    print(load_dict)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。
JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、Java、
JavaScript、Perl、Python 等)。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也
易于机器解析和生成(一般用于提升网络传输速率)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>线性模型</title>
    <link href="http://yoursite.com/2018/08/23/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/08/23/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2018-08-23T04:38:12.000Z</published>
    <updated>2020-01-08T17:46:11.241Z</updated>
    
    <content type="html"><![CDATA[<h1>基本形式</h1><p>由$d$个属性描述的实例$x=(x_1; x_2; ...; x_d)$，线性回归试图学得一个通过属性的线性组合来预测的函数：</p><p>$$ f(x)=w_1 x_1 + w_2 x_2 + ... + w_d x_d + b $$</p><a id="more"></a><p>向量形式写成：$$ f(x)=w^T x+b $$其中 $w = (w_1; w_2; ...; w_d)$</p><h1>线性回归</h1><p>设样本集的数目为$m$，$x$代表输入变量（特征），$y$代表输出变量（目标），$(x,y)$代表样本集中的实例，$(x^i,y^i)$代表样本集中第$i$个实例，函数$f(x)$是模型的假设。</p><h2>1. 损失函数</h2><p>模型的参数$w, b$决定模型预测能力的好坏，模型在训练集中的预测值与实际值的差距是我们的建模误差，代价函数即定义为建模误差的平方和：</p><p>$ J(w, b) = \frac{1}{2m} \sum_{i=1}^{m}(f(x^i)-y^i)^2 $</p><p>我们的目标是选择使代价函数最小的模型参数。</p><h2>2. 梯度下降法</h2><p>$w = w - \alpha \frac{\partial}{\partial w}J(w,b)$</p><p>$b = b - \alpha \frac{\partial}{\partial b}J(w,b)$</p><p>$\alpha$ 是学习率</p><p>$\frac{\partial}{\partial b}J(w,b) = \frac{1}{m}\sum_{i=1}^{m}(f(x^i)-y^i)$</p><p>$\frac{\partial}{\partial w}J(w,b) = \frac{1}{m}\sum_{i=1}^{m}((f(x^i)-y^i) x^i)$</p><h2>3. 最小二乘法</h2><h1>逻辑回归</h1><p>逻辑回归用来处理$y$值是离散情况的分类问题。</p><h2>1. 分类问题</h2><h2>2. 假说表示</h2><h2>3. 判定边界</h2><h2>4. 代价函数与梯度下降</h2><h1>正则化</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;基本形式&lt;/h1&gt;
&lt;p&gt;由$d$个属性描述的实例$x=(x_1; x_2; ...; x_d)$，线性回归试图学得一个通过属性的线性组合来预测的函数：&lt;/p&gt;
&lt;p&gt;$$ f(x)=w_1 x_1 + w_2 x_2 + ... + w_d x_d + b $$&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MNIST数据集</title>
    <link href="http://yoursite.com/2018/08/23/mnist%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%AF%BC%E5%85%A5/"/>
    <id>http://yoursite.com/2018/08/23/mnist%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%AF%BC%E5%85%A5/</id>
    <published>2018-08-23T02:21:00.000Z</published>
    <updated>2020-01-08T18:00:52.492Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MNIST 数据集</strong>可在 <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a> 获取，它包含了四个部分：</p><a id="more"></a><ul><li><p><strong>Training set images：</strong></p><p>train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</p></li><li><p><strong>Training set labels：</strong></p><p>train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</p></li><li><p><strong>Test set images：</strong></p><p>t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</p></li><li><p><strong>Test set labels：</strong></p><p>t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</p></li></ul><p>MNIST 数据集来自美国国家标准与技术研究所，<strong>National Institute of Standards and Technology (NIST)</strong>，训练集 (training set) 由来自 250 个不同人手写的数字构成，其中 50% 是高中学生，50% 来自人口普查局 (the Census Bureau) 的工作人员。测试集(test set) 也是同样比例的手写数字数据。</p><p>图片是以字节的形式进行存储, 我们需要把它们读取到 NumPy array 中，以便训练和测试算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_mnist</span><span class="params">(path, kind=<span class="string">'train'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Load MNIST data from `path`"""</span></span><br><span class="line">    labels_path = os.path.join(path,</span><br><span class="line">                               <span class="string">'%s-labels-idx1-ubyte'</span></span><br><span class="line">                               % kind)</span><br><span class="line">    images_path = os.path.join(path,</span><br><span class="line">                               <span class="string">'%s-images-idx3-ubyte'</span></span><br><span class="line">                               % kind)</span><br><span class="line">    <span class="keyword">with</span> open(labels_path, <span class="string">'rb'</span>) <span class="keyword">as</span> lbpath:</span><br><span class="line">        magic, n = struct.unpack(<span class="string">'&gt;II'</span>,</span><br><span class="line">                                 lbpath.read(<span class="number">8</span>))</span><br><span class="line">        labels = np.fromfile(lbpath,</span><br><span class="line">                             dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(images_path, <span class="string">'rb'</span>) <span class="keyword">as</span> imgpath:</span><br><span class="line">        magic, num, rows, cols = struct.unpack(<span class="string">'&gt;IIII'</span>,</span><br><span class="line">                                               imgpath.read(<span class="number">16</span>))</span><br><span class="line">        images = np.fromfile(imgpath,</span><br><span class="line">                             dtype=np.uint8).reshape(len(labels), <span class="number">784</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images, labels</span><br></pre></td></tr></table></figure><p><code>load_mnist</code> 函数返回两个数组，第一个是一个 n x m 维的 NumPy array(<code>images</code>)，这里的 n 是样本数(行数)，m 是特征数(列数)。训练数据集包含 60000 个样本，测试数据集包含 10000 样本。在 MNIST 数据集中的每张图片由 28 x 28 个像素点构成，每个像素点用一个灰度值表示。在这里, 我们将 28 x 28 的像素展开为一个一维的行向量，这些行向量就是图片数组里的行(每行 784 个值，或者说每行就是代表了一张图片)。 <code>load_mnist</code> 函数返回的第二个数组(<code>labels</code>) 包含了相应的目标变量，也就是手写数字的类标签(整数 0-9)。</p><p>通过执行上面的代码，我们将会从刚刚解压 MNIST 数据集后的 mnist 目录下加载 60000 个训练样本和 10000 个测试样本。</p><p>为了了解 MNIST 中的图片看起来到底是个啥，让我们来对它们进行可视化处理。从 feature matrix 中将 784-像素值的向量 reshape 为之前的 28*28 的形状，然后通过 matplotlib 的 <code>imshow</code> 函数进行绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(</span><br><span class="line">    nrows=<span class="number">2</span>,</span><br><span class="line">    ncols=<span class="number">5</span>,</span><br><span class="line">    sharex=<span class="keyword">True</span>,</span><br><span class="line">    sharey=<span class="keyword">True</span>, )</span><br><span class="line"></span><br><span class="line">ax = ax.flatten()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    img = X_train[y_train == i][<span class="number">0</span>].reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    ax[i].imshow(img, cmap=<span class="string">'Greys'</span>, interpolation=<span class="string">'nearest'</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_xticks([])</span><br><span class="line">ax[<span class="number">0</span>].set_yticks([])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>此外，我们还可以绘制某一数字的多个样本图片，来看一下这些手写样本到底有多不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(</span><br><span class="line">    nrows=<span class="number">5</span>,</span><br><span class="line">    ncols=<span class="number">5</span>,</span><br><span class="line">    sharex=<span class="keyword">True</span>,</span><br><span class="line">    sharey=<span class="keyword">True</span>, )</span><br><span class="line"></span><br><span class="line">ax = ax.flatten()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">    img = X_train[y_train == <span class="number">7</span>][i].reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    ax[i].imshow(img, cmap=<span class="string">'Greys'</span>, interpolation=<span class="string">'nearest'</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_xticks([])</span><br><span class="line">ax[<span class="number">0</span>].set_yticks([])</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;MNIST 数据集&lt;/strong&gt;可在 &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://yann.lecun.com/exdb/mnist/&lt;/a&gt; 获取，它包含了四个部分：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>csv格式文件的导入与导出</title>
    <link href="http://yoursite.com/2018/08/22/csv%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2018/08/22/csv%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/</id>
    <published>2018-08-22T08:34:09.000Z</published>
    <updated>2020-01-08T17:58:55.471Z</updated>
    
    <content type="html"><![CDATA[<p>在数据处理中，常遇到csv格式的文件，下面简要介绍如何使用Python中的Pandas模块来读取csv文件中的数据。</p><a id="more"></a><h2>CSV文件格式</h2><p>CSV(Comma-Separated Values)文件以纯文本形式存储表格数据，文件由任意数目的记录组成，记录间以换行符分隔，每条记录由字段组成，字段间的分隔符可自定义，通常是逗号。下面的数据取自Kaggle中Titanic的乘客信息数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PassengerId,Pclass,Name,Sex,Age,SibSp,Parch,Ticket,Fare,Cabin,Embarked</span><br><span class="line">892,3,&quot;Kelly, Mr. James&quot;,male,34.5,0,0,330911,7.8292,,Q</span><br><span class="line">893,3,&quot;Wilkes, Mrs. James (Ellen Needs)&quot;,female,47,1,0,363272,7,,S</span><br><span class="line">894,2,&quot;Myles, Mr. Thomas Francis&quot;,male,62,0,0,240276,9.6875,,Q</span><br><span class="line">895,3,&quot;Wirz, Mr. Albert&quot;,male,27,0,0,315154,8.6625,,S</span><br><span class="line">896,3,&quot;Hirvonen, Mrs. Alexander (Helga E Lindqvist)&quot;,female,22,1,1,3101298,12.2875,,S</span><br><span class="line">897,3,&quot;Svensson, Mr. Johan Cervin&quot;,male,14,0,0,7538,9.225,,S</span><br><span class="line">898,3,&quot;Connolly, Miss. Kate&quot;,female,30,0,0,330972,7.6292,,Q</span><br><span class="line">899,2,&quot;Caldwell, Mr. Albert Francis&quot;,male,26,1,1,248738,29,,S</span><br><span class="line">900,3,&quot;Abrahim, Mrs. Joseph (Sophie Halaut Easu)&quot;,female,18,0,0,2657,7.2292,,C</span><br><span class="line">901,3,&quot;Davies, Mr. John Samuel&quot;,male,21,2,0,A/4 48871,24.15,,S</span><br></pre></td></tr></table></figure><h2>Pandas模块</h2><ol><li><p>导入pandas模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure></li><li><p>读取csv文件中的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">"train.csv"</span>,sep=<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p>参数<code>sep</code>设定csv文件中分隔符，默认为<code>,</code>。</p></li><li><p>数据集对应的参数名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.columns</span><br></pre></td></tr></table></figure></li><li><p>第 $i$ 条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[i-1]</span><br></pre></td></tr></table></figure></li><li><p>数据集的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.shape</span><br></pre></td></tr></table></figure></li><li><p>数据集的描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.describe</span><br></pre></td></tr></table></figure></li><li><p>数据集参数数组里的不同值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic[<span class="string">'Sex'</span>].unique()</span><br></pre></td></tr></table></figure></li><li><p>数据集字符串到数字的映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic.loc[titanic[<span class="string">'Sex'</span>]==<span class="string">'male'</span>,<span class="string">'Sex'</span>]=<span class="number">0</span></span><br><span class="line">titanic.loc[titanic[<span class="string">'Sex'</span>]==<span class="string">'female'</span>,<span class="string">'Sex'</span>]=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>数据集中缺失数据的补填</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic[<span class="string">'Age'</span>]=titanic[<span class="string">'Age'</span>].fillna(titanic[<span class="string">'Age'</span>].median())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数据处理中，常遇到csv格式的文件，下面简要介绍如何使用Python中的Pandas模块来读取csv文件中的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
</feed>
